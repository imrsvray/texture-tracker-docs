<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
  <title>vplibs - header</title>
  <meta name="GENERATOR" content="Quanta Plus">
  <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</head>
<body>
 <table>
  <tbody>
<tr align="left" valign="top" bgcolor="#ccffff">
<td width="100%">
<table>
  <tbody>
    <tr>
      <td> <a href="/project/vp/vplibs/index.html"><h3> BBC R&amp;D VP
Libraries: </h3></a></td> 
      <td> <a href="/project/vp/vplibs/soGeM/doc/index.html">soGeM</a> |
</td>
      <td> <a 
href="/project/vp/vplibs/VPtexturing/doc/index.html">VPtexturing</a> |
</td>

	<td> <a href="/project/vp/vplibs/VPgeom/doc/index.html">VPgeom</a> |
</td>      
	<td> <a href="/project/vp/vplibs/VPio/doc/index.html">VPio</a> | </td>
	<td> <a href="/project/vp/vplibs/VPip/doc/index.html">VPip</a> | </td>
	<td> <a href="/project/vp/vplibs/VPutil/doc/index.html">VPutil</a> | </td>
        <td> VPai | </td>
      <td> DVSlib | </td>
    </tr>
  </tbody>
</table>
</td>
</tr>
<tr align="left" valign="top" bgcolor="#FFFFFF#ccffff">
<td width="100%">

<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1>Solve.cc</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">* File: Solve.cpp</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 2004 The British Broadcasting Corporation.</span>
00005 <span class="comment">* &lt;b&gt;ALL RIGHTS RESERVED&lt;/b&gt;.</span>
00006 <span class="comment">*</span>
00007 <span class="comment">* Copyright in the whole and every part of these source files belongs</span>
00008 <span class="comment">* to The British Broadcasting Corporation (BBC) and they</span>
00009 <span class="comment">* may not be used, sold, licenced, transferred, copied or reproduced</span>
00010 <span class="comment">* in whole or in part in any manner or form or in or on any media to</span>
00011 <span class="comment">* any person without the prior written consent of the BBC.</span>
00012 <span class="comment">*/</span>
00013 
00014 <span class="preprocessor">#include "Solve.h"</span>
00015 
00016 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00017 <span class="keyword">using</span> <span class="keyword">namespace </span>bbcvp;
00018 
<a name="l00022"></a><a class="code" href="classbbcvp_1_1Solve.html#a0">00022</a> Solve::Solve()
00023 {
00024 
00025 }
00026 
00027 
<a name="l00032"></a><a class="code" href="classbbcvp_1_1Solve.html#a1">00032</a> Solve::~Solve()
00033 {
00034 
00035 }
00036 
00037 
00038 <span class="comment">/*</span>
00039 <span class="comment">* solve (public method)</span>
00040 <span class="comment">*/</span>
00041 
<a name="l00042"></a><a class="code" href="classbbcvp_1_1Solve.html#a2">00042</a> Solve::solveRetCode Solve::solve ( <span class="keyword">const</span> <span class="keywordtype">double</span>* a, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* b, <span class="keywordtype">double</span>* x )
00043 {
00044   <span class="keyword">static</span> <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;
00045   <span class="keyword">static</span> <span class="keywordtype">int</span> allocated_size;
00046   <span class="keyword">static</span> <span class="keywordtype">double</span>* t;
00047 
00048   <span class="comment">// allocate the memory for t once only - some PC implementations seem to have poor/non-existant garbage collection!</span>
00049   <span class="keywordflow">if</span> (first)
00050     {
00051       allocated_size = <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*n * (n+1);
00052       t = (<span class="keywordtype">double</span>*)malloc(allocated_size);
00053       <span class="keywordflow">if</span> (t == NULL)
00054         {
00055           <span class="comment">//printf("ERROR: solve: malloc failed on first call to solve\n");</span>
00056           <span class="comment">//exit(-1);</span>
00057           <span class="keywordflow">return</span> (Solve::SOLVE_MALLOC_FAILED);
00058         }
00059       first=<span class="keyword">false</span>;
00060     }
00061 
00062   <span class="comment">// if previous call was for fewer equations - must free &amp; reallocate</span>
00063   <span class="keywordflow">if</span> (allocated_size &lt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*n * (n+1))
00064     {
00065       free(t);
00066       allocated_size = <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*n * (n+1);
00067       t = (<span class="keywordtype">double</span>*)malloc(allocated_size);
00068       <span class="keywordflow">if</span> (t == NULL)
00069         {
00070           <span class="comment">//printf("ERROR: solve: malloc failed on subsequent call to solve\n");</span>
00071           <span class="comment">//exit(-1);</span>
00072           <span class="keywordflow">return</span>(Solve::SOLVE_MALLOC_FAILED);
00073         }
00074     }
00075 
00076   calcTMatrixTR(a, b, t, n, m);
00077 
00078   <span class="keywordflow">return</span> solveTMatrix(t, x, n);
00079 
00080   free(t);
00081 
00082 }
00083 
00084 
00085 
00089 <span class="keywordtype">void</span> Solve::calcTMatrixTR ( <span class="keyword">const</span> <span class="keywordtype">double</span> *cc, <span class="keyword">const</span> <span class="keywordtype">double</span> *value, <span class="keywordtype">double</span> *t, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> ns)
00090 {
00091   <span class="keywordtype">double</span> a;
00092   <span class="keywordtype">int</span>    r, c, i;
00093 
00094   <span class="keywordflow">for</span> (r = 0; r &lt; n; r++)
00095     <span class="keywordflow">for</span> (c = r; c &lt; n; c++)
00096       {
00097         a = 0.0;
00098         <span class="keywordflow">for</span> (i = 0; i &lt; ns; i++)
00099           a += cc[i*n+r] * cc[i*n+c];
00100         t[r+n*c] = a;
00101         t[c+n*r] = a;
00102       }
00103   <span class="keywordflow">for</span> (r = 0; r &lt; n; r++)
00104     {
00105       a = 0.0;
00106       <span class="keywordflow">for</span> (i = 0; i &lt; ns; i++)
00107         a += cc[i*n+r] * value[i];  <span class="comment">// removed * weight[i]</span>
00108       t[r+n*n] = a;
00109     }
00110 }
00111 
00112 
00117 Solve::solveRetCode Solve::solveTMatrix ( <span class="keywordtype">double</span> *t, <span class="keywordtype">double</span> *s, <span class="keywordtype">int</span> n )
00118 {
00119   <span class="keywordtype">double</span> x, y;
00120   <span class="keywordtype">int</span>    i, j, k;
00121   <span class="keywordtype">bool</span> noSolution;
00122 
00123   <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
00124     {
00125       noSolution = <span class="keyword">true</span>;
00126       i = j;
00127       <span class="keywordflow">while</span> ( noSolution &amp;&amp; (i &lt; n) )
00128         {
00129           <span class="keywordflow">if</span> ((t[i+n*j] &gt; 1e-50) || (t[i+n*j] &lt; -1e-50))
00130             noSolution = <span class="keyword">false</span>;
00131           <span class="keywordflow">else</span>
00132             i++;
00133         }
00134       <span class="keywordflow">if</span> (noSolution) <span class="keywordflow">break</span>;
00135       <span class="keywordflow">for</span> (k = 0; k &lt;= n; k++)
00136         {
00137           x = t[j+n*k];
00138           t[j+n*k] = t[i+n*k];
00139           t[i+n*k] = x;
00140         }
00141       y = 1 / t[j+n*j];
00142       <span class="keywordflow">for</span> (k = 0; k &lt;= n; k++)
00143         t[j+n*k] = y * t[j+n*k];
00144       <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
00145         {
00146           <span class="keywordflow">if</span> (i != j)
00147             {
00148               y = -t[i+n*j];
00149               <span class="keywordflow">for</span> (k = j; k &lt;= n; k++)
00150                 t[i+n*k] = t[i+n*k] + (y * t[j+n*k]);
00151             }
00152         }
00153     }
00154   <span class="keywordflow">if</span> (noSolution)
00155     <span class="keywordflow">return</span> (Solve::SOLVE_NO_SOLUTION);
00156   <span class="keywordflow">else</span>
00157     {
00158       <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
00159         s[i] = t[i+n*n];
00160       <span class="keywordflow">return</span> (Solve::SOLVE_SUCCESS);
00161     }
00162 }
00163 
00164 
00165 
00166 
00167 
</pre></div></td>
</tr>
  </tbody>
</table>
</body>
</html>
