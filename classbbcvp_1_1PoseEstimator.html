<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
  <title>vplibs - header</title>
  <meta name="GENERATOR" content="Quanta Plus">
  <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</head>
<body>
 <table>
  <tbody>
<tr align="left" valign="top" bgcolor="#ccffff">
<td width="100%">
<table>
  <tbody>
    <tr>
      <td> <a href="/project/vp/vplibs/index.html"><h3> BBC R&amp;D VP
Libraries: </h3></a></td> 
      <td> <a href="/project/vp/vplibs/soGeM/doc/index.html">soGeM</a> |
</td>
      <td> <a 
href="/project/vp/vplibs/VPtexturing/doc/index.html">VPtexturing</a> |
</td>

	<td> <a href="/project/vp/vplibs/VPgeom/doc/index.html">VPgeom</a> |
</td>      
	<td> <a href="/project/vp/vplibs/VPio/doc/index.html">VPio</a> | </td>
	<td> <a href="/project/vp/vplibs/VPip/doc/index.html">VPip</a> | </td>
	<td> <a href="/project/vp/vplibs/VPutil/doc/index.html">VPutil</a> | </td>
        <td> VPai | </td>
      <td> DVSlib | </td>
    </tr>
  </tbody>
</table>
</td>
</tr>
<tr align="left" valign="top" bgcolor="#FFFFFF#ccffff">
<td width="100%">

<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1>bbcvp::PoseEstimator Class Reference</h1>Estimates internal/external parameters of one or more cameras or objects in one or more images.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PoseEstimator_8h-source.html">PoseEstimator.h</a>&gt;</code>
<p>
<p>Inheritance diagram for bbcvp::PoseEstimator:
<p><center><img src="classbbcvp_1_1PoseEstimator.png" usemap="#bbcvp::PoseEstimator_map" border="0" alt=""></center>
<map name="bbcvp::PoseEstimator_map">
<area href="classbbcvp_1_1PoseEstimatorSoGeM.html" alt="bbcvp::PoseEstimatorSoGeM" shape="rect" coords="0,56,174,80">
</map>
<a href="classbbcvp_1_1PoseEstimator-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a0">PoseEstimator</a> (int maxPoints=100, int maxImages=1, int maxCameras=1, int maxObjects=1, int maxLines=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="bbcvp::PoseEstimator::~PoseEstimator"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a1">~PoseEstimator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a2">setCameraData</a> (double **positionCam, double **rotationCam, double **intrinPar, int nCameras=1, bool **adjustPositionCam=(bool **) 0, bool **adjustRotationCam=(bool **) 0, bool **adjustIntrinPar=(bool **) 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify addresses of arrays holding data referring to the camera(s). </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a3">setCameraRange</a> (int startCam, int endCam)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the range of the cameras to process. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a4">setObjectData</a> (double ***positionObj, double ***rotationObj, int nObjects=1, bool ***adjustPositionObj=(bool ***) 0, bool ***adjustRotationObj=(bool ***) 0, int **constrainZAxisYDirObj=(int **) 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify addresses of arrays holding data referring to the object(s). </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a5">setPointsData</a> (double ****worldPoints, double *****imagePoints, int **nPoints, int nImages=1, bool **useImObj=(bool **) 0, bool ****usePoint=(bool ****) 0, double ****weightPoint=(double ****) 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify addresses of arrays holding data referring to the observed points. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a6">setLinesData</a> (double *****worldLines, double ******imageLines, int **nLines, int nImages=1, bool **useImObj=(bool **) 0, bool ****useLine=(bool ****) 0, double ****weightLine=(double ****) 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify addresses of arrays holding data referring to the observed lines. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a7">setVerticalFOV</a> (double fovyRad, int cam=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the focal length of the given camera, for the given field-of-view in radians. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a8">setVerticalFOVDeg</a> (double fovy, int cam=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the focal length of the given camera, for the given field-of-view in degrees. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a9">getVerticalFOV</a> (int cam=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the vertical field-of view of given camera, in radians. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a10">getVerticalFOVDeg</a> (int cam=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the vertical field-of view of given camera, in degrees. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a11">setTerminationConditions</a> (double rmsLimit, int maxIter, double limit, double maxRmsErrorIncrease=0.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the conditions under which the iteraterative solution process terminates. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a12">setVerbosity</a> (int verbosity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the verbosity level. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a13">roughEstimateObject</a> (int cam=0, int image=0, int obj=0, double typicalObjectDistance=3.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Roughly estimate the initial position and z rotation of the given object, using data from the given camera image. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a14">roughEstimateCamera</a> (int cam=0, int image=0, int obj=0, double typicalObjectDistance=3.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimate the initial position and orientation of the given camera, using the given camera image. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a new estimate for the camera and/or object data, using the points and/or lines data. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a16">calcSolutionRansac</a> (double maxInlierDist, double minInlierFraction, int maxTries, bool useInitialGuess, int nInitialPoints, bool ****inlierPoint, int *nFinalPoints=(int *) 0, int nInitialLines=0, bool ****inlierLine=(bool ****) 0, int *nFinalLines=(int *) 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a new estimate for the camera and/or object data, using the points and/or lines data, using a RANSAC approach. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a17">calcSolutionWithUnknownObjectRotation</a> (double *rotRange, int *rotNStep, int image=0, int obj=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a new estimate for the camera and/or object data, using the points data, by starting with a range of values for the rotation of the given object in the given frame. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a18">oneIteration</a> (double *rmsError)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform one iteration to compute a new estimate for the camera and/or object data, using the points data. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a19">PoseEstimator::calcRelWorldPosArbitraryPoint</a> (int cam, int image, int obj, double wx, double wy, double wz, double *rwx, double *rwy, double *rwz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the world position of the given 3D point, in the reference frame of the given camera. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a20">calcImagePositionPoint</a> (int cam, int image, int obj, int point, double *xPos, double *yPos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the position in the image of the given object point, in metres from image centre. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a21">calcImagePositionArbitraryPoint</a> (int cam, int image, int obj, double wx, double wy, double wz, double *xPos, double *yPos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the position in the image of the given 3D point, specified in the reference frame of the given object, in metres from image centre. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a22">calcImagePositionLine</a> (int cam, int image, int obj, int line, double *xPosStart, double *yPosStart, double *xPosEnd, double *yPosEnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the position in the image of the given object line, in metres from image centre. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a23">calcImagePositionPixelsArbitraryLine</a> (int cam, int image, int obj, double startWx, double startWy, double startWz, double endWx, double endWy, double endWz, double *startX, double *startY, double *endX, double *endY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the projection of the given arbitrary 3D line in the reference frame of the given object into the image of the given camera, as (clipped) pixel coordinates. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a24">calcImagePositionArbitraryLine</a> (int cam, int image, int obj, double startWx, double startWy, double startWz, double endWx, double endWy, double endWz, double *startX, double *startY, double *endX, double *endY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the projection of the given arbitrary 3D line in the reference frame of the given object into the image of the given camera, in metres from the image centre. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a25">calcImageErrorPoint</a> (int cam, int image, int obj, int point, double *x, double *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the error in units of vertical pixel spacing between where a point was observed and where it would be expected to appear. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a26">calcImageErrorLine</a> (int cam, int image, int obj, int line, double *errStart, double *errEnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the error in units of pixels between the end points of the given line as observed in the image, and the closest point on the 3D line projected into the image. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a27">calcRMSErrorPoints</a> (double *rmsError, int cam=-1, int image=-1, int object=-1, int point=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the RMS error in vertical pixel spacing between where points were observed and where they would be expected to appear. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a28">calcRMSErrorLines</a> (double *rmsError, int cam=-1, int image=-1, int object=-1, int line=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the RMS error in vertical pixel spacing between where lines were observed and where they would be expected to appear. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a29">calcRMSError</a> (double *rmsError, int cam=-1, int image=-1, int object=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the RMS error in vertical pixel spacing for both points and lines. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a30">calcWorldPoints</a> (double **worldCoords, int image=0, int obj=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the world coordinates of the points on the given object in the given image. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a31">calcImagePoints</a> (double **imagePoints, int cam=0, int image=0, int obj=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the image coordinates (in pixels) of the points on the given object in the given image. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a32">calcImageLines</a> (double ***imageLines, int cam=0, int image=0, int obj=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the image coordinates (in pixels) of the lines on the given object in the given image. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a33">calcRotMatObj</a> (int image, int obj, double *rotMat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the rotation matrix for the given object in the given image, and write it into the given 9-element array. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classbbcvp_1_1PoseEstimator.html#a34">calcRotMatCam</a> (int cam, double *rotMat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the rotation matrix for the given object in the given image, and write it into the given 9-element array. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p0" doxytag="bbcvp::PoseEstimator::mVerbose"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>mVerbose</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p1" doxytag="bbcvp::PoseEstimator::mNCameras"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>mNCameras</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p2" doxytag="bbcvp::PoseEstimator::mStartCam"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>mStartCam</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p3" doxytag="bbcvp::PoseEstimator::mEndCam"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>mEndCam</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p4" doxytag="bbcvp::PoseEstimator::mPositionCam"></a>
double **&nbsp;</td><td class="memItemRight" valign=bottom><b>mPositionCam</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p5" doxytag="bbcvp::PoseEstimator::mRotationCam"></a>
double **&nbsp;</td><td class="memItemRight" valign=bottom><b>mRotationCam</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p6" doxytag="bbcvp::PoseEstimator::mIntrinPar"></a>
double **&nbsp;</td><td class="memItemRight" valign=bottom><b>mIntrinPar</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p7" doxytag="bbcvp::PoseEstimator::mAdjustPositionCam"></a>
bool **&nbsp;</td><td class="memItemRight" valign=bottom><b>mAdjustPositionCam</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p8" doxytag="bbcvp::PoseEstimator::mAdjustRotationCam"></a>
bool **&nbsp;</td><td class="memItemRight" valign=bottom><b>mAdjustRotationCam</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p9" doxytag="bbcvp::PoseEstimator::mAdjustIntrinPar"></a>
bool **&nbsp;</td><td class="memItemRight" valign=bottom><b>mAdjustIntrinPar</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p10" doxytag="bbcvp::PoseEstimator::mAllCamPosFixed"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>mAllCamPosFixed</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p11" doxytag="bbcvp::PoseEstimator::mAllCamRotFixed"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>mAllCamRotFixed</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p12" doxytag="bbcvp::PoseEstimator::mAllCamIntrinFixed"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>mAllCamIntrinFixed</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p13" doxytag="bbcvp::PoseEstimator::mNObjects"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>mNObjects</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p14" doxytag="bbcvp::PoseEstimator::mPositionObj"></a>
double ***&nbsp;</td><td class="memItemRight" valign=bottom><b>mPositionObj</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p15" doxytag="bbcvp::PoseEstimator::mRotationObj"></a>
double ***&nbsp;</td><td class="memItemRight" valign=bottom><b>mRotationObj</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p16" doxytag="bbcvp::PoseEstimator::mAdjustPositionObj"></a>
bool ***&nbsp;</td><td class="memItemRight" valign=bottom><b>mAdjustPositionObj</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p17" doxytag="bbcvp::PoseEstimator::mAdjustRotationObj"></a>
bool ***&nbsp;</td><td class="memItemRight" valign=bottom><b>mAdjustRotationObj</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p18" doxytag="bbcvp::PoseEstimator::mConstrainZAxisYDirObj"></a>
int **&nbsp;</td><td class="memItemRight" valign=bottom><b>mConstrainZAxisYDirObj</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p19" doxytag="bbcvp::PoseEstimator::mAllObjPosFixed"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>mAllObjPosFixed</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p20" doxytag="bbcvp::PoseEstimator::mAllObjRotFixed"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>mAllObjRotFixed</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p21" doxytag="bbcvp::PoseEstimator::mAllZAxisYDirObjUnconstrained"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>mAllZAxisYDirObjUnconstrained</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p22" doxytag="bbcvp::PoseEstimator::mNImages"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>mNImages</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p23" doxytag="bbcvp::PoseEstimator::mUseImObj"></a>
bool **&nbsp;</td><td class="memItemRight" valign=bottom><b>mUseImObj</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p24" doxytag="bbcvp::PoseEstimator::mUseAllImObj"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>mUseAllImObj</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p25" doxytag="bbcvp::PoseEstimator::mNPoints"></a>
int **&nbsp;</td><td class="memItemRight" valign=bottom><b>mNPoints</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p26" doxytag="bbcvp::PoseEstimator::mWorldPoints"></a>
double ****&nbsp;</td><td class="memItemRight" valign=bottom><b>mWorldPoints</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p27" doxytag="bbcvp::PoseEstimator::mImagePoints"></a>
double *****&nbsp;</td><td class="memItemRight" valign=bottom><b>mImagePoints</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p28" doxytag="bbcvp::PoseEstimator::mUsePoint"></a>
bool ****&nbsp;</td><td class="memItemRight" valign=bottom><b>mUsePoint</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p29" doxytag="bbcvp::PoseEstimator::mWeightPoint"></a>
double ****&nbsp;</td><td class="memItemRight" valign=bottom><b>mWeightPoint</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p30" doxytag="bbcvp::PoseEstimator::mUseAllPoints"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>mUseAllPoints</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p31" doxytag="bbcvp::PoseEstimator::mNLines"></a>
int **&nbsp;</td><td class="memItemRight" valign=bottom><b>mNLines</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p32" doxytag="bbcvp::PoseEstimator::mWorldLines"></a>
double *****&nbsp;</td><td class="memItemRight" valign=bottom><b>mWorldLines</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p33" doxytag="bbcvp::PoseEstimator::mImageLines"></a>
double ******&nbsp;</td><td class="memItemRight" valign=bottom><b>mImageLines</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p34" doxytag="bbcvp::PoseEstimator::mUseLine"></a>
bool ****&nbsp;</td><td class="memItemRight" valign=bottom><b>mUseLine</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p35" doxytag="bbcvp::PoseEstimator::mWeightLine"></a>
double ****&nbsp;</td><td class="memItemRight" valign=bottom><b>mWeightLine</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="p36" doxytag="bbcvp::PoseEstimator::mUseAllLines"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>mUseAllLines</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Estimates internal/external parameters of one or more cameras or objects in one or more images. 
<p>
Given a list of image points and their corresponding points in 3D space in the reference frame of an object, it adjusts all unknowns so as to minimise the square error in image space. The method that calculates this solution requires estimated values for all unknowns; other methods are provided to perform this initial estimation if required, although in some applications a good estimate will already be available (e.g. the position in a previous image).<p>
This class may be used to solve a range of problems, from computing the relative position of a camera given the coordinates at which it sees some known calibration points, through to the complete calibration of a multi-camera rig given data from a number of images showing one or more calibration objects in unknown poses.<p>
Each potentially-adjustable value may optionally be fixed at a given value, by setting the corresponding element of a bool array to true or false. This allows the solution to be constrained in various ways, e.g. constraining the position and orientation of the object allows the camera position and orientation to be computed in a defined reference frame, or disabling adjustment of the camera internal parameters allows values from a prior calibration process to be used.<p>
Each 3D point is described in terms of its positon in the reference frame of a given "object". Each object's reference frame can be different in each "image" of data. So, for example, to calibrate a camera using multiple views of a calibration object in unknown positions, the points on the calibration object are specified with respect to the calibration object's reference frame, which itself is unknown and solved for by this class. The position and orientation of the object could be fixed in one or more images so that the computed positions/orientations were with respect to a defined refernce frame. Conversely, if multiple objects were being tracked by a single camera and we wanted to work out their position with respect to the camera, then we could create multiple objects, and fix the position of the camera. If all camera parameters were fixed, this would give the same result as calling the class separately for each object, but by solving for all object poses in one process it becomes possible to, for example, optimise the focal length of the camera using data from all objects simultaneously.<p>
All variables are passed in and out in multi-dimensional double-precision arrays. These arrays are actually stored as pointers-to-pointers-to-... rather than genuine multi-dimensional arrays, so that the dimensions do not need to be fixed at compile time. Useful functions for allocating / deallocating such arrays may be found in the module nd_array in the VPutil library. Positions and angles are placed in array elements 0,1,2 for X,Y,Z, and internal camera parameters have #define'd constants to specify where each unknown is placed.<p>
This class does not depend on any non-standard libraries. If you want to work with camera objects as represented in the soGeM library, you might like to use the <a class="el" href="classbbcvp_1_1PoseEstimatorSoGeM.html">PoseEstimatorSoGeM</a> derived class instead.<p>
<dl compact><dt><b>Author:</b></dt><dd>Graham Thomas, BBC R&amp;D </dd></dl>
<dl compact><dt><b>Version:</b></dt><dd>1.2 </dd></dl>

<p>

<p>
Definition at line <a class="el" href="PoseEstimator_8h-source.html#l00085">85</a> of file <a class="el" href="PoseEstimator_8h-source.html">PoseEstimator.h</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="bbcvp::PoseEstimator::PoseEstimator"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bbcvp::PoseEstimator::PoseEstimator </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxPoints</em> = 100, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxImages</em> = 1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxCameras</em> = 1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxObjects</em> = 1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxLines</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. 
<p>
Allocates internal storage for working space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>maxPoints</em>&nbsp;</td><td>The maximum number of unique points visible on an object at any one time instant. For example, if 50 points were visible to one camera, and a DIFFERENT 50 were visible to another camera at the same time, this counts as a total of 100. All the values in the array nPoints[im][obj] should be less than or equal to this value. </td></tr>
    <tr><td valign=top><em>maxImages</em>&nbsp;</td><td>The maximum number of images to be used simultaneously. This will be 1 in most simple applications, but for applications such as performing a full calibration of the internal and external parameters of a camera, multiple images can be used to get more accurate results. </td></tr>
    <tr><td valign=top><em>maxCameras</em>&nbsp;</td><td>The maximum number of cameras to use simultaneously. This will usually be 1 unless a multi-camera rig is being calibrated, or unless clever tricks are being played such as using several known relative camera poses to calculate the position common to all cameras. </td></tr>
    <tr><td valign=top><em>maxObjects</em>&nbsp;</td><td>The maximum number of independently-moving objects to use in the calibration process. This will usually be 1.</td></tr>
    <tr><td valign=top><em>maxLines</em>&nbsp;</td><td>The maximum number of unique lines visible on an object at any one time instant; equivalent to maxPoints but for lines. All the values in the array nLines[im][obj] should be less than or equal to this value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a26" doxytag="bbcvp::PoseEstimator::calcImageErrorLine"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool bbcvp::PoseEstimator::calcImageErrorLine </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>line</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>errStart</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>errEnd</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the error in units of pixels between the end points of the given line as observed in the image, and the closest point on the 3D line projected into the image. 
<p>
Useful for detecting outliers, or examining the distribution of errors. May be called before calling <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a> to check how reasonable the initial estimate is. NB the error is computed in undistorted image coordinates - usually this will be almost identical to the error in the distorted world if there is negligible change in distortion over the distance of the error. Also note that if the 3D position of both ends of a line put it behind the camera, the error is effectively infinite (returned as 1.0e10). Furthermore, note that this function does not check for the arguments being in range! The units of the error are vertical line spacing, NOT pixels and lines: this is so the errors correspond to equal distances on the image sensor and pixel aspect ratio does not change the relative weightings of horizontal and vertical error.<p>
Note that this method does not check whether the line is disabled via the array useLine. This array is checked, however, when the RMS error over all points is computed by <a class="el" href="classbbcvp_1_1PoseEstimator.html#a28">calcRMSErrorLines()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>line</em>&nbsp;</td><td>The line for which to perform the calculation (0..nLines[cam][obj]-1) </td></tr>
    <tr><td valign=top><em>errStart,errEnd</em>&nbsp;</td><td>The locations to which to return the computed error values </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if the line was visible, false if the line was disabled (i.e. imageLine start was -1) </dd></dl>
    </td>
  </tr>
</table>
<a name="a25" doxytag="bbcvp::PoseEstimator::calcImageErrorPoint"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool bbcvp::PoseEstimator::calcImageErrorPoint </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>point</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the error in units of vertical pixel spacing between where a point was observed and where it would be expected to appear. 
<p>
Useful for detecting outliers, or examining the distribution of errors. May be called before calling <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a> to check how reasonable the initial estimate is. NB the error is computed in undistorted image coordinates<ul>
<li>usually this will be almost identical to the error in the distorted world if there is negligible change in distortion over the distance of the error. Also note that if the 3D position of a visible point puts it behind the camera, the error is effectively infinite (returned as 1.0e10). Furthermore, note that this function does not check for the arguments being in range! The units of the error are vertical line spacing, NOT pixels and lines: this is so the errors correspond to equal distances on the image sensor and pixel aspect ratio does not change the relative weightings of horizontal and vertical error.</li></ul>
<p>
Note that this method does not check whether the point is disabled via the array usePoint. This array is checked, however, when the RMS error over all points is computed by <a class="el" href="classbbcvp_1_1PoseEstimator.html#a27">calcRMSErrorPoints()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>point</em>&nbsp;</td><td>The point for which to perform the calculation (0..nPoints[cam][obj]-1) </td></tr>
    <tr><td valign=top><em>x,y</em>&nbsp;</td><td>The locations to which to return the error values </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if the point was visible, false if the point was disabled (i.e. imagePoints was -1) </dd></dl>
    </td>
  </tr>
</table>
<a name="a32" doxytag="bbcvp::PoseEstimator::calcImageLines"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::calcImageLines </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double ***&nbsp;</td>
          <td class="mdname" nowrap> <em>imageLines</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the image coordinates (in pixels) of the lines on the given object in the given image. 
<p>
The 3D lines stored in worldLines[image][obj] are projected into the given camera. NB currently the effect of lens distortion is NOT included; this will be added shortly! Useful for working out where all the lines on an object would appear, for example to generate test data, or to compute the reprojection error in pixels and lines including distortion (when this is added!). (Note that calcImageError() ignores distortion and works in units of line spacing to be compatible with the quantity that is minimised by <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a>.<p>
This function is implemented simply by calling <a class="el" href="classbbcvp_1_1PoseEstimator.html#a23">calcImagePositionPixelsArbitraryLine()</a> for all of the nLines[image][obj] lines on the given object in the given image.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>imageLines</em>&nbsp;</td><td>imageLines[line][start=0|end=1][X|Y]: the image coordinates for each line in the given image. The arrays must be at least of length nLines[image][obj]. NB lines that are behind the camera or land at pixel coordinates outside the given image size will have their coordinates set to -1. </td></tr>
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The number of the camera whose view of the obejct is to be computed. </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The number of the image in which the object position is wanted </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The number of the object whose image coordinates to compute. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a31" doxytag="bbcvp::PoseEstimator::calcImagePoints"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::calcImagePoints </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double **&nbsp;</td>
          <td class="mdname" nowrap> <em>imagePoints</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the image coordinates (in pixels) of the points on the given object in the given image. 
<p>
The 3D points stored in worldPoints[image][obj] are projected into the given camera. NB currently the effect of lens distortion is NOT included; this will be added shortly! Useful for working out where all the points on an object would appear, for example to generate test data, or to compute the reprojection error in pixels and lines including distortion (when this is added!). (Note that calcImageError() ignores distortion and works in units of line spacing to be compatible with the quantity that is minimised by <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>imagePoints</em>&nbsp;</td><td>imagePoints[point][X|Y]: the image coordinates for each point in the given image. The arrays must be at least of length nPoints[image][obj]. NB points that are behind the camera or land at pixel coordinates outside the given image size will have their coordinates set to -1. </td></tr>
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The number of the camera whose view of the obejct is to be computed. </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The number of the image in which the object position is wanted </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The number of the object whose image coordinates to compute. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a24" doxytag="bbcvp::PoseEstimator::calcImagePositionArbitraryLine"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool bbcvp::PoseEstimator::calcImagePositionArbitraryLine </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>startWx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>startWy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>startWz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>endWx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>endWy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>endWz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>startX</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>startY</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>endX</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>endY</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the projection of the given arbitrary 3D line in the reference frame of the given object into the image of the given camera, in metres from the image centre. 
<p>
The returned coordinates are not clipped to lie within the active image area. The effect of lens distortion is not yet implemented! If the line is wholly behind the camera, the coordinate values are not set and the method returns false.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>startWx,startWy,startWz</em>&nbsp;</td><td>The 3D point at the start of the line </td></tr>
    <tr><td valign=top><em>endWx,endWy,endWz</em>&nbsp;</td><td>The 3D point at the end of the line </td></tr>
    <tr><td valign=top><em>startX,startY</em>&nbsp;</td><td>The locations to which to return the point position (in m) of the line start </td></tr>
    <tr><td valign=top><em>endX,endY</em>&nbsp;</td><td>The locations to which to return the point position (in m) of the line end </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if the line was partly or wholly visible, false if the line was wholly behind the camera. </dd></dl>
    </td>
  </tr>
</table>
<a name="a21" doxytag="bbcvp::PoseEstimator::calcImagePositionArbitraryPoint"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool bbcvp::PoseEstimator::calcImagePositionArbitraryPoint </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>wx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>wy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>wz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>xPos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>yPos</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the position in the image of the given 3D point, specified in the reference frame of the given object, in metres from image centre. 
<p>
NB does not check for point lying in "active" area of image sensor. Similar to <a class="el" href="classbbcvp_1_1PoseEstimator.html#a20">calcImagePositionPoint()</a>, except that instead of using the 3D coordinates previously specified for a point, arbitrary coordinates can be given.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>wx,wy,wz</em>&nbsp;</td><td>The 3D point whose projected position to calculate </td></tr>
    <tr><td valign=top><em>x,y</em>&nbsp;</td><td>The locations to which to return the point position </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if the point was visible, false if the point behind the camera </dd></dl>
    </td>
  </tr>
</table>
<a name="a22" doxytag="bbcvp::PoseEstimator::calcImagePositionLine"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool bbcvp::PoseEstimator::calcImagePositionLine </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>line</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>xPosStart</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>yPosStart</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>xPosEnd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>yPosEnd</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the position in the image of the given object line, in metres from image centre. 
<p>
NB does not check for point lying in "active" area of image sensor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>line</em>&nbsp;</td><td>The line for which to perform the calculation (0..nLines[cam][obj]-1) </td></tr>
    <tr><td valign=top><em>xPosStart,yPosStart</em>&nbsp;</td><td>The locations to which to return the start point position </td></tr>
    <tr><td valign=top><em>xPosEnd,yPosEnd</em>&nbsp;</td><td>The locations to which to return the end point position </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if the point was visible, false if the point behind the camera </dd></dl>
    </td>
  </tr>
</table>
<a name="a23" doxytag="bbcvp::PoseEstimator::calcImagePositionPixelsArbitraryLine"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool bbcvp::PoseEstimator::calcImagePositionPixelsArbitraryLine </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>startWx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>startWy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>startWz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>endWx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>endWy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>endWz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>startX</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>startY</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>endX</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>endY</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the projection of the given arbitrary 3D line in the reference frame of the given object into the image of the given camera, as (clipped) pixel coordinates. 
<p>
NB the effect of lens distortion is not yet implemented! If the line lies partly outside the image, it is clipped to lie within the image area. If the line is wholly outside the image (including being behind the camera), the coordinates are set to -1 and the method returns false.<p>
This method is implemented using <a class="el" href="classbbcvp_1_1PoseEstimator.html#a24">calcImagePositionArbitraryLine()</a>, then converting from metres to pixel coordinates and clipping the line to lie within the image.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>startWx,startWy,startWz</em>&nbsp;</td><td>The 3D point at the start of the line </td></tr>
    <tr><td valign=top><em>endWx,endWy,endWz</em>&nbsp;</td><td>The 3D point at the end of the line </td></tr>
    <tr><td valign=top><em>startX,startY</em>&nbsp;</td><td>The locations to which to return the point position (in pixels) of the line start </td></tr>
    <tr><td valign=top><em>endX,endY</em>&nbsp;</td><td>The locations to which to return the point position (in pixels) of the line end </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if the line was partly or wholly visible, false if the point behind the camera. </dd></dl>
    </td>
  </tr>
</table>
<a name="a20" doxytag="bbcvp::PoseEstimator::calcImagePositionPoint"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool bbcvp::PoseEstimator::calcImagePositionPoint </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>point</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>xPos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>yPos</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the position in the image of the given object point, in metres from image centre. 
<p>
NB does not check for point lying in "active" area of image sensor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>point</em>&nbsp;</td><td>The point for which to perform the calculation (0..nPoints[cam][obj]-1) </td></tr>
    <tr><td valign=top><em>x,y</em>&nbsp;</td><td>The locations to which to return the point position </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if the point was visible, false if the point behind the camera </dd></dl>
    </td>
  </tr>
</table>
<a name="a29" doxytag="bbcvp::PoseEstimator::calcRMSError"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int bbcvp::PoseEstimator::calcRMSError </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rmsError</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>object</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the RMS error in vertical pixel spacing for both points and lines. 
<p>
The methods <a class="el" href="classbbcvp_1_1PoseEstimator.html#a27">calcRMSErrorPoints()</a> and <a class="el" href="classbbcvp_1_1PoseEstimator.html#a28">calcRMSErrorLines()</a> are used to compute the errors from points and lines. The total RMS error is then computed as follows (following the usual definition of RMS error):<p>
RMSErrTotal = sqrt ( RMSPoints*RMSPoints*NPoints + RMSLines*RMSLines*NLines ) / (NPoints + NLines)<p>
Note that unlike <a class="el" href="classbbcvp_1_1PoseEstimator.html#a27">calcRMSErrorPoints()</a> and <a class="el" href="classbbcvp_1_1PoseEstimator.html#a28">calcRMSErrorLines()</a>, it is not possible to select an individual point and line - if you want to know about the error for a particular feature, call the point or line method separately, which allows an individual index to be sepecified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rmsError</em>&nbsp;</td><td>Pointer to where to write the computed RMS error (zero is written if no lines are visible) </td></tr>
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>object</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of lines over which the error was computed </dd></dl>
    </td>
  </tr>
</table>
<a name="a28" doxytag="bbcvp::PoseEstimator::calcRMSErrorLines"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int bbcvp::PoseEstimator::calcRMSErrorLines </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rmsError</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>object</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>line</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the RMS error in vertical pixel spacing between where lines were observed and where they would be expected to appear. 
<p>
By default, the error is computed for all lines in all objects visible in all images and the whole range of camera values (excluding lines disabled by setting useLine[cam][image][obj][line] to false). However, by specifying a particular number for cam, image, object or line, the computation can be limited to just this subset. Specifying a number out-of-range will cause the full range to be used. For example, if you want to compute the RMS error for a particular image for all cameras, call the function with cam=-1, image equal to the image number you want, and omit object and line so they default to -1. Useful for detecting an anomalous image, for example caused by failure to detect the position of a calibration object in one image. May be called before calling <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a> to check how reasonable the initial estimate is.<p>
Note that this method uses calcImageErrorLine - see the notes on this for further details, including the behaviour when a visible line is apparently behind the camera.<p>
This function is analagous to <a class="el" href="classbbcvp_1_1PoseEstimator.html#a27">calcRMSErrorPoints()</a>, but operates on lines rather than points.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rmsError</em>&nbsp;</td><td>Pointer to where to write the computed RMS error (zero is written if no lines are visible) </td></tr>
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>object</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>line</em>&nbsp;</td><td>The line for which to perform the calculation (0..nLines[cam][object]-1) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of lines over which the error was computed </dd></dl>
    </td>
  </tr>
</table>
<a name="a27" doxytag="bbcvp::PoseEstimator::calcRMSErrorPoints"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int bbcvp::PoseEstimator::calcRMSErrorPoints </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rmsError</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>object</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>point</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the RMS error in vertical pixel spacing between where points were observed and where they would be expected to appear. 
<p>
By default, the error is computed for all points in all objects visible in all images and the whole range of cameras (excluding points disabled by setting usePoint[cam][image][obj][point] to false). However, by specifying a particular number for cam, image, object or point, the computation can be limited to just this subset. Specifying a number out-of-range will cause the full range to be used. For example, if you want to compute the RMS error for a particular image for all cameras, call the function with cam=-1, image equal to the image number you want, and omit object and point so they default to -1. Useful for detecting an anomalous image, for example caused by failure to detect the position of a calibration object in one image. May be called before calling <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a> to check how reasonable the initial estimate is.<p>
Note that this method uses calcImageError - see the notes on this for further details, including the behaviour when a visible point is apparently behind the camera.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rmsError</em>&nbsp;</td><td>Pointer to where to write the computed RMS error (zero is written if no points are visible) </td></tr>
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>object</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>point</em>&nbsp;</td><td>The point for which to perform the calculation (0..nPoints[cam][object]-1) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of points over which the error was computed </dd></dl>
    </td>
  </tr>
</table>
<a name="a34" doxytag="bbcvp::PoseEstimator::calcRotMatCam"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::calcRotMatCam </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rotMat</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the rotation matrix for the given object in the given image, and write it into the given 9-element array. 
<p>
The matrix is written in column order, i.e. rotMat[0]=matrix(1,1), rotMat[1]=matrix(1,2), rotMat[2]=matrix(1,3), rotMat[1]=matrix(2,1), and so on. This ordering is useful in that the first 3 elements of rotMat correspond to the vector which (1,0,0) on the camera becomes in the world reference frame, the next 3 are what (0,1,0) becomes (i.e. the up vector) ,and the last 3 are what (0,0,1) become (ie. minus the view vector). The matrix will be the identity matrix if all angles are zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The number of the camera for which the object rotation matrix is wanted </td></tr>
    <tr><td valign=top><em>rotMat</em>&nbsp;</td><td>Pointer to the start of an array of 9 doubles into which to write the matrix elements. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a33" doxytag="bbcvp::PoseEstimator::calcRotMatObj"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::calcRotMatObj </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rotMat</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the rotation matrix for the given object in the given image, and write it into the given 9-element array. 
<p>
The matrix is written in column order, i.e. rotMat[0]=matrix(1,1), rotMat[1]=matrix(1,2), rotMat[2]=matrix(1,3), rotMat[1]=matrix(2,1), and so on. This ordering is useful in that the first 3 elements of rotMat correspond to the vector which (1,0,0) on the object becomes in the world reference frame, the next 3 are what (0,1,0) becomes,and the last 3 are what (0,0,1) become.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The number of the image for which the object rotation matrix is wanted </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The number of the object for which the object rotation matrix is wanted </td></tr>
    <tr><td valign=top><em>rotMat</em>&nbsp;</td><td>Pointer to the start of an array of 9 doubles into which to write the matrix elements. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a15" doxytag="bbcvp::PoseEstimator::calcSolution"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double bbcvp::PoseEstimator::calcSolution </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a new estimate for the camera and/or object data, using the points and/or lines data. 
<p>
Estimated values replace the current values in the various arrays. The conditions for terminating the iterative process should already have been set using setIterationParams(), and the camera, object and points data arrays must also have been set using the corresponding methods. These camera and object arrays must already contain a reasonable estimate of the solution; if necessary call the methods <a class="el" href="classbbcvp_1_1PoseEstimator.html#a14">roughEstimateCamera()</a> and/or roughEstimateObjectPosition() and <a class="el" href="classbbcvp_1_1PoseEstimator.html#a17">calcSolutionWithUnknownObjectRotation()</a> to achieve this.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The RMS error for the new solution, or a negative value if no solution could be found. -1 means that the computation did not converge in the given number of iterations, probably due to a poor initial estiamte, or inconsistent image/world point data. -2 meant that the no solution could be found to the simultaneous equations formed during an iteration; this may indicate that there were too few observed points to solve for all the unknowns. </dd></dl>
    </td>
  </tr>
</table>
<a name="a16" doxytag="bbcvp::PoseEstimator::calcSolutionRansac"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double bbcvp::PoseEstimator::calcSolutionRansac </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>maxInlierDist</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>minInlierFraction</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxTries</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>useInitialGuess</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nInitialPoints</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool ****&nbsp;</td>
          <td class="mdname" nowrap> <em>inlierPoint</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>nFinalPoints</em> = (int *) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nInitialLines</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool ****&nbsp;</td>
          <td class="mdname" nowrap> <em>inlierLine</em> = (bool ****) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>nFinalLines</em> = (int *) 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a new estimate for the camera and/or object data, using the points and/or lines data, using a RANSAC approach. 
<p>
Estimated values replace the current values in the various arrays.<p>
A random set of nInitialPoints and nInitialLines is chosen for each camera to use when computing a solution. That is, for each camera, a random image and object are chosen, and a random point on this object is selected, and the process is repeated until nInitialPoints have been chosen. The selection process is then repeated for lines. The complete set of lines and/or points are then tested to see which observations lie less than inlierDist from where they would be expected to appear, given the computed solution. If this number is greater than inlierFraction of the total number of lines+points, then the solution is recomputed using these inliers, and the method returns. If maxTries sets are tried and still insufficient inliers are found, then the solution with the largest number of inliers is returned. The number of points and lines used in the final solution are returned in nFinalPoints and nFinalLines; to find out whether the maximum number of iterations were used, check if these add up to more than inlierFraction of the total. The arrays inlierPoint and inlierLine are returned with elements set to true or false, to indicate whether each was used in the final solution. If the argument useInitialGuess is set to true, then the first set of points/lines used will be those indicated in the inlierPoint/inlierLine arrays. For example, if very few outliers are expected, you could set all elements in these arrays to true, and set useInitialGuess to true, to have all points used to derive a first guess. Note that points disabled by the usePoint/useLine arrays (if used) are always ignored, and corresponding elements of the returned arrays will always be false.<p>
The conditions for terminating the basic iterative solution process should already have been set using setIterationParams(), and the camera, object and points data arrays must also have been set using the corresponding methods. These camera and object arrays must already contain a reasonable estimate of the solution; if necessary call the methods <a class="el" href="classbbcvp_1_1PoseEstimator.html#a14">roughEstimateCamera()</a> and/or roughEstimateObjectPosition() and <a class="el" href="classbbcvp_1_1PoseEstimator.html#a17">calcSolutionWithUnknownObjectRotation()</a> to achieve this.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>maxInlierDist</em>&nbsp;</td><td>The max. distance in pixels that points and/or line ends can be from the reporjected positions to be considered inliers</td></tr>
    <tr><td valign=top><em>minInlierFraction</em>&nbsp;</td><td>The minimum fraction of total points+lines that must be inliers for the process to stop.</td></tr>
    <tr><td valign=top><em>maxTries</em>&nbsp;</td><td>Maximum number of random sets to try before giving up</td></tr>
    <tr><td valign=top><em>useInitialGuess</em>&nbsp;</td><td>Set to true to use initial state of inlierPoint/inlierLine arrays as the first guess.</td></tr>
    <tr><td valign=top><em>nInitialPoints</em>&nbsp;</td><td>The number of points to randomly select</td></tr>
    <tr><td valign=top><em>inlierPoint</em>&nbsp;</td><td>inlierPoint[cam][image][obj][point] is set to true/false depending on whether this point is an inlier or not. Can be set to 0 if no points are to be considered, as the array is not then needed.</td></tr>
    <tr><td valign=top><em>nFinalPoints</em>&nbsp;</td><td>Pointer to where to return the number of points to used in the returned solution (set to 0 if you don't want this value returned)</td></tr>
    <tr><td valign=top><em>nInitialLines</em>&nbsp;</td><td>The number of lines to randomly select</td></tr>
    <tr><td valign=top><em>inlierLine</em>&nbsp;</td><td>inlierLine[cam][image][obj][line] is set to true/false depending on whether this line is an inlier or not. Can be set to 0 if no lines are to be considered, as the array is not then needed.</td></tr>
    <tr><td valign=top><em>nFinalLines</em>&nbsp;</td><td>Pointer to where to return the number of lines to used in the returned solution (set to 0 if you don't want this value returned)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The RMS error for the new solution, or a negative value if no solution could be found. -1 means that the computation did not converge in the given number of iterations for any of the combinations tested, probably due to a poor initial estiamte, inconsistent image/world point data, or too few initial points/lines being used. </dd></dl>
    </td>
  </tr>
</table>
<a name="a17" doxytag="bbcvp::PoseEstimator::calcSolutionWithUnknownObjectRotation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double bbcvp::PoseEstimator::calcSolutionWithUnknownObjectRotation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rotRange</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>rotNStep</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a new estimate for the camera and/or object data, using the points data, by starting with a range of values for the rotation of the given object in the given frame. 
<p>
This method is very similar to <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a>; however it tolerates more uncertainty in the orientation of the given object in the given frame, but is slower. As for <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a>, the conditions for terminating the iterative process should already have been set using setIterationParams(), and the camera, object and points data arrays must also have been set using the corresponding methods. The camera and object arrays must already contain a reasonable estimate of the solution, although unlike <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a>, the rotation of the specified object in the given frame can have a wide range of uncertainty. This method calls <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a> several times, using different initial orientation values offset from those currently set. For example, if rotationObj[im][obj][X] = 0.2 radians, rotRange[X]=0.1 and rotNStep[X]=3, then the x rotation values that will be tested are 0.1, 0.2, 0.3. All combination of angles are tested, so the total number of calls to <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a> will be rotNStep[X]*rotNStep[Y]*rotNStep[Z]. The calculated angles and positions that give the lowest final RMS error will be left in the approporate elements of the object postion &amp; rotation arrays, and this lowest RMS error will be returned. The solution calculation uses all cameras and image data as specified in the main arrays. Note that it is usually desireable to fix the positions of all the cameras whilst performing the initial object pose estimation, but not essential, for example if some other combination of camera and object parameters are fixed. If other objects are defined in the main arrays, these will be considered in the calculation as well, but only the specified object in the given image will have its rotations varied. If any of the orientation values for this object in this image are flagged as being fixed by the data arrays, the value will not be changed (this is equivalent to forcing rotRange to 0 and rotNStep to 1 for this parameter).<p>
TODO: make this optionally test rotation variations for all objects in all frames and with a range of variations for all cameras - specify -1 for camera, object or frame index to mean "separately apply the range of initial rotations to all of these"<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rotRange</em>&nbsp;</td><td>rotRange[X|Y|Z] the range of values either side of the current value for the angle that will be tested. </td></tr>
    <tr><td valign=top><em>rotNStep[X|Y|Z]</em>&nbsp;</td><td>the total number of steps that will be used to test each angle. </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>the index of the image data set in which to vary the object initial rotation </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>the index of the object to use to estimate the camera parameters</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The RMS error for the new solution, or a negative value if no solution could be found. -1 means that none of the tested starting conditions converged. </dd></dl>
    </td>
  </tr>
</table>
<a name="a30" doxytag="bbcvp::PoseEstimator::calcWorldPoints"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::calcWorldPoints </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double **&nbsp;</td>
          <td class="mdname" nowrap> <em>worldCoords</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the world coordinates of the points on the given object in the given image. 
<p>
The 3D points stored in worldPoints[image][obj] are rotated by the inverse of the object rotation, and translated by the given object position, to convert them into world coordinates. Useful for working out where all the points on an object are, for example to re-project them into a camera image to visualise how well they fit the image of the object. Used internally by roughEstimateCamera.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>worldCoords</em>&nbsp;</td><td>worldCoords[point][X|Y|Z]: array of pointers at least nPoints[image][obj] long, that point to arrays to take 3 doubles </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The number of the image in which the object position is wanted </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The number of the object whose point coordinates to compute. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a9" doxytag="bbcvp::PoseEstimator::getVerticalFOV"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double bbcvp::PoseEstimator::getVerticalFOV </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cam</em> = 0          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the vertical field-of view of given camera, in radians. 
<p>
Requires that internal parameters number of vertical pixels (NY), vertical pixel spacing (YP), and focal length (F) are already set for the given camera. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>fovyRad</em>&nbsp;</td><td>vertical field-of-view, in radians. </td></tr>
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>the number of the camera whose focal length to set </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>vertical field-of-view, in radians </dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="bbcvp::PoseEstimator::getVerticalFOVDeg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double bbcvp::PoseEstimator::getVerticalFOVDeg </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cam</em> = 0          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the vertical field-of view of given camera, in degrees. 
<p>
Requires that internal parameters number of vertical pixels (NY), vertical pixel spacing (YP), and focal length (F) are already set for the given camera. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>fovyRad</em>&nbsp;</td><td>vertical field-of-view, in radians. </td></tr>
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>the number of the camera whose focal length to set </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>vertical field-of-view, in degrees </dd></dl>
    </td>
  </tr>
</table>
<a name="a18" doxytag="bbcvp::PoseEstimator::oneIteration"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double bbcvp::PoseEstimator::oneIteration </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rmsError</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform one iteration to compute a new estimate for the camera and/or object data, using the points data. 
<p>
Estimated values replace the current values in the various arrays. The camera, object and points data arrays must also have been set using the corresponding methods. These camera and object arrays must already contain a reasonable estimate of the solution; if necessary call the methods estimateCameraPose() and/or estimateObjectPose() to achieve this.<p>
You probably don't need to call this method, as the <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a> method is provided to call it repeatedly until the termination conditions are satisfied.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>the</em>&nbsp;</td><td>location into which to write the new RMS error </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the length of the adjustment vector applied to the unknowns. This gives an indication of how much the solution has been changed. </dd></dl>
    </td>
  </tr>
</table>
<a name="a19" doxytag="bbcvp::PoseEstimator::PoseEstimator::calcRelWorldPosArbitraryPoint"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::PoseEstimator::calcRelWorldPosArbitraryPoint </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>wx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>wy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>wz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rwx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rwy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>rwz</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the world position of the given 3D point, in the reference frame of the given camera. 
<p>
The camera reference frame has +x to the right, +y up, and a viewing direction of -z.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The camera for which to perform the calculation (0..nCameras-1) </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The image for which to perform the calculation (0..nImages-1) </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The object for which to perform the calculation (0..nObjects-1) </td></tr>
    <tr><td valign=top><em>wx,wy,wz</em>&nbsp;</td><td>The 3D point whose projected position to calculate </td></tr>
    <tr><td valign=top><em>rwx,rwy,rwz</em>&nbsp;</td><td>The locations into which to return the relative world posiiton </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a14" doxytag="bbcvp::PoseEstimator::roughEstimateCamera"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::roughEstimateCamera </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>typicalObjectDistance</em> = 3.0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Estimate the initial position and orientation of the given camera, using the given camera image. 
<p>
Note that this does NOT estimate any intrinsic parameters, (i.e. those in the array intrinPar as passed to <a class="el" href="classbbcvp_1_1PoseEstimator.html#a2">setCameraData()</a> ), and these must be set before calling this function. Any position and orientation values that are marked as not-to-be-adjusted will be left unchanged. Note also that the algorithm is very simple: it assumes the camera is looking down the -z axis (i.e. x and y angles are zero), and calculates the camera's z angle (roll) based on the observed position of the two points on the object that are as close to being in a plane parallel to the camera sensor. The x,y camera coordinates are set to the x,y coordinates of one of these object points, and the z is set to the average of the z coordinate of these points, plus an estimate of the distance frm camera to object. This algorithm should be suffcient to generate a reasonable starting point for the iterative computation, as long as the assumption about approximate camera viewing direction is correct. If this assumption is not generally true for a particular application, another method should be used - e.g. add a method like <a class="el" href="classbbcvp_1_1PoseEstimator.html#a17">calcSolutionWithUnknownObjectRotation()</a> but for cameras!<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The index of the camera whose view to use when estimating the object position </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The index of the image data set to use to perform the estimation </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The index of the object whose position and orientation are to be estimated </td></tr>
    <tr><td valign=top><em>typicalObjectDistance</em>&nbsp;</td><td>Typical distance from camera to object in metres; used to help estimatoin process if very few points are visible </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a13" doxytag="bbcvp::PoseEstimator::roughEstimateObject"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::roughEstimateObject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>typicalObjectDistance</em> = 3.0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Roughly estimate the initial position and z rotation of the given object, using data from the given camera image. 
<p>
NB this assumes that the object's x and y angles are close to zero (indeed, it sets them to zero), so all it really estimates is the distance from object to camera, and the relative 'roll'. The values of positionObj[image][obj][X|Y|Z] are set so as to place the object in front of the camera. Any position or orientation values that are marked as not-to-be-adjusted will be left unchanged.<p>
If you know that the assumptions about the object having zero x and y angles are likely to be correct for your application, then it should be sufficient just to use this function before calling <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a> for the first time. However, if the x and y angles of the object are likely to differ significantly from zero (more than 30-40 degrees, say), then you might want to call <a class="el" href="classbbcvp_1_1PoseEstimator.html#a17">calcSolutionWithUnknownObjectRotation()</a> instead of <a class="el" href="classbbcvp_1_1PoseEstimator.html#a15">calcSolution()</a> to search around the possible object angles.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>The index of the camera whose image points to use </td></tr>
    <tr><td valign=top><em>image</em>&nbsp;</td><td>The index of the image data set to use to perform the estimation </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>The index of the object whose position should be estimated </td></tr>
    <tr><td valign=top><em>typicalObjectDistance</em>&nbsp;</td><td>Typical distance from camera to object in metres; used to help estimation process if very few points are visible </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="bbcvp::PoseEstimator::setCameraData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::setCameraData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double **&nbsp;</td>
          <td class="mdname" nowrap> <em>positionCam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double **&nbsp;</td>
          <td class="mdname" nowrap> <em>rotationCam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double **&nbsp;</td>
          <td class="mdname" nowrap> <em>intrinPar</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nCameras</em> = 1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool **&nbsp;</td>
          <td class="mdname" nowrap> <em>adjustPositionCam</em> = (bool **) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool **&nbsp;</td>
          <td class="mdname" nowrap> <em>adjustRotationCam</em> = (bool **) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool **&nbsp;</td>
          <td class="mdname" nowrap> <em>adjustIntrinPar</em> = (bool **) 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specify addresses of arrays holding data referring to the camera(s). 
<p>
These arrays only need to be specified once, but this method may be called several times if it is desired to re-compute using different data arrays, or if the number of cameras changes. Note that it is only the addresses of the arrays that are stored - the data is not read in/out of the arrays until a compute method is called.<p>
Camera rotation is specified in terms of three Euler angles, as used (for example) by openGL. When all angles are zero, the camera is looking down the -ve z axis with y pointing up. Camera intrinsic parameters are specified as follows:<p>
F is focal length in metres<p>
CX,CY are the distance (in metres) to the centre of the image from pixel (0,0) (CX is +ve, CY is -ve to account for the y axis in pixel coordinates pointing down)<p>
XP,YP are the spacings of the pixels im metres in the x and y direction (YP is -ve to account for the y axis in pixel coordinates pointing down.<p>
NX, NY are the number of pixels horizontally and vertically in the camera image. These are needed in order to define sensible default values for CX and CY, and could be used in order to derive a measure of centre posiiton which is with respect ot the central pixel rather than the top-left one as represented by CX,CY.<p>
D,D1,D2,D4 are used to model lens distortion, such that<p>
undistoted radius = r * (1 + d*r^2 + d1*r^3 + d2*r^4 + d4*r^6)<p>
where r is the radius from the centre of the image in the presence of lens distortion. If all are zero then there is no lens distortion.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>position[cam][X|Y|Z]</em>&nbsp;</td><td>input/output position for each camera, in metres. </td></tr>
    <tr><td valign=top><em>rotationCam[cam][X|Y|Z]</em>&nbsp;</td><td>input/output rotation for each camera, in radians. </td></tr>
    <tr><td valign=top><em>intrinPar[cam][F|D|D1|D2|D4|CX|CY|XP|YP|NX|NY]</em>&nbsp;</td><td>input/output intrinsic parameters for each camera </td></tr>
    <tr><td valign=top><em>nCameras</em>&nbsp;</td><td>number of cameras in the arrays provided (by dafault, all of these are used in the computations unless the range is restricted using <a class="el" href="classbbcvp_1_1PoseEstimator.html#a3">setCameraRange()</a> ). </td></tr>
    <tr><td valign=top><em>adjustPosCam[cam][X|Y|Z]</em>&nbsp;</td><td>whether to adjust each pos coord of each camera. If omitted (or specified as NULL), then all positions are fixed. </td></tr>
    <tr><td valign=top><em>adjustAngCam[cam][X|Y|Z]</em>&nbsp;</td><td>whether to adjust each angle of each camera. If omitted (or specified as NULL), then all rotations are fixed. </td></tr>
    <tr><td valign=top><em>adjustIntrinPar[cam][F|D|D1|D2|D4|CX|CY]</em>&nbsp;</td><td>whether to adjust the int params of each camera. If omitted (or specified as NULL), then all internal parameters are fixed. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="bbcvp::PoseEstimator::setCameraRange"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::setCameraRange </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>startCam</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>endCam</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the range of the cameras to process. 
<p>
By default, all cameras with indices from from 0..nCameras-1 are processed, but this range can be restricted by calling this function after calling <a class="el" href="classbbcvp_1_1PoseEstimator.html#a2">setCameraData()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>startCam</em>&nbsp;</td><td>The index of the first camera to process </td></tr>
    <tr><td valign=top><em>endCam</em>&nbsp;</td><td>The index of the last camera to process (to process just one camera, set endCam equal to startCam) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a6" doxytag="bbcvp::PoseEstimator::setLinesData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::setLinesData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *****&nbsp;</td>
          <td class="mdname" nowrap> <em>worldLines</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double ******&nbsp;</td>
          <td class="mdname" nowrap> <em>imageLines</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>nLines</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nImages</em> = 1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool **&nbsp;</td>
          <td class="mdname" nowrap> <em>useImObj</em> = (bool **) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool ****&nbsp;</td>
          <td class="mdname" nowrap> <em>useLine</em> = (bool ****) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double ****&nbsp;</td>
          <td class="mdname" nowrap> <em>weightLine</em> = (double ****) 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specify addresses of arrays holding data referring to the observed lines. 
<p>
These arrays only need to be specified once, but this method may be called several times if it is desired to re-compute using different data arrays, or if the number of points or images changes. Note that it is only the addresses of the arrays that are stored - the data is not read in/out of the arrays until a compute method is called.<p>
Note that the constructor sets nLines to NULL, indicating that there are no lines in any image or object, so if you don't want to use lines at all, you need not call this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>worldLines</em>&nbsp;</td><td>worldLines[image][obj][line][start=0|end=1][X|Y|Z]: The world coordinates of the start and end points of each line, in the reference frame of the object, in the given image. Note that although the world points on each object are by definition fixed over time in its reference frame, not all points will generally be visible in each image, and this array holds only those that are visible - hence the need for the [image] index. </td></tr>
    <tr><td valign=top><em>imageLines</em>&nbsp;</td><td>imageLines[cam][image][obj][line][start=0|end=1][X|Y]: The image coordinates of each line on each object, in the given image for each camera. Set start to (-1,-1) if the line was not seen for a given image from a given camera. Lines that are not seen from any camera can be omitted simply by not including an entry for them in both the arrays. </td></tr>
    <tr><td valign=top><em>nLines[image][obj]</em>&nbsp;</td><td>Number of observed lines in each image for each object. </td></tr>
    <tr><td valign=top><em>nImages</em>&nbsp;</td><td>Number of separate time instants (images) at which observations were made. Note this value is common between the observed points and lines, and the value set by the most recent call to either <a class="el" href="classbbcvp_1_1PoseEstimator.html#a5">setPointsData()</a> or <a class="el" href="classbbcvp_1_1PoseEstimator.html#a6">setLinesData()</a> will be used. If both point and line arrays are specified, each must have entries in their nPoints and nLines arrays for every frame and object, even if these entries are zero. </td></tr>
    <tr><td valign=top><em>useImObj</em>&nbsp;</td><td>useImObj[image][obj]: specifies whether to use observations from each image of each object; if omitted then all images and objects will be used. This array is common to the array specified in <a class="el" href="classbbcvp_1_1PoseEstimator.html#a5">setPointsData()</a>; if both points and lines are used then the same array should be specified. </td></tr>
    <tr><td valign=top><em>useLine</em>&nbsp;</td><td>useLine[cam][image][obj][line]: specifies whether to use this observation; if omitted then all observed lines will be used. Useful to "turn off" a particular individual observation, e.g. if it was considered an outlier. </td></tr>
    <tr><td valign=top><em>weightLine</em>&nbsp;</td><td>weightLine[cam][image][obj][line] specifies the weighting to apply to this observation of this line. Omitting this array sets a default weight of 1 to all lines. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="bbcvp::PoseEstimator::setObjectData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::setObjectData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double ***&nbsp;</td>
          <td class="mdname" nowrap> <em>positionObj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double ***&nbsp;</td>
          <td class="mdname" nowrap> <em>rotationObj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nObjects</em> = 1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool ***&nbsp;</td>
          <td class="mdname" nowrap> <em>adjustPositionObj</em> = (bool ***) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool ***&nbsp;</td>
          <td class="mdname" nowrap> <em>adjustRotationObj</em> = (bool ***) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>constrainZAxisYDirObj</em> = (int **) 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specify addresses of arrays holding data referring to the object(s). 
<p>
These arrays only need to be specified once, but this method may be called several times if it is desired to re-compute using different data arrays, or if the number of objects changes. Note that it is only the addresses of the arrays that are stored - the data is not read in/out of the arrays until a compute method is called.<p>
A note about constraining the Z axis: in applications where the object is planar, with points only in the xy plane in the object's reference frame (e.g. tracking a pattern on a flat card), there can be uncertainty in the signs of the x and y angles. This is because changing the signs of both of these angles together doesn't change the world x and y coordinates of any points in the plane of the object; it only changes their z coordinates. If the object is a long way from the camera compared to its dimensions, then there will be very little perspective effect, and it will be difficult or impossible to distinguish these two orientation possibilities. If we know a priori that the object is likely to be facing up rather than down, then we can pick the orientation that gives the y component of the z axis of the object a positive value; conversely if we know it is likely to be facing down then we can pick the other possibility. A priori knowledge of this sort can optionally be indicated through the array constrainZAxisYDirObj.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>positionObj[image][obj][X|Y|Z]</em>&nbsp;</td><td>input/output position for each object </td></tr>
    <tr><td valign=top><em>rotationObj[image][obj][X|Y|Z]</em>&nbsp;</td><td>input/output rotation for each object </td></tr>
    <tr><td valign=top><em>nObjects</em>&nbsp;</td><td>number of objects </td></tr>
    <tr><td valign=top><em>adjustPositionObj[image][obj][X|Y|Z]</em>&nbsp;</td><td>whether to adjust each pos coord of each object. If omitted then all position coordinates of all objects are fixed. </td></tr>
    <tr><td valign=top><em>adjustRotationObj[image][obj][X|Y|Z]</em>&nbsp;</td><td>whether to adjust each angle of each object If omitted then all angles of all objects are fixed. </td></tr>
    <tr><td valign=top><em>constrainZAxisYDirObj[image][obj]</em>&nbsp;</td><td>whether to constrain the y component of the Z axis of the object to be positive (constrainZAxisYDirObj=1), negative (constrainZAxisYDirObj=-1) or unconstrained (constrainZAxisYDirObj=0). If omitted then no constraints are placed on the z axis. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a5" doxytag="bbcvp::PoseEstimator::setPointsData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::setPointsData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double ****&nbsp;</td>
          <td class="mdname" nowrap> <em>worldPoints</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *****&nbsp;</td>
          <td class="mdname" nowrap> <em>imagePoints</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nImages</em> = 1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool **&nbsp;</td>
          <td class="mdname" nowrap> <em>useImObj</em> = (bool **) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool ****&nbsp;</td>
          <td class="mdname" nowrap> <em>usePoint</em> = (bool ****) 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double ****&nbsp;</td>
          <td class="mdname" nowrap> <em>weightPoint</em> = (double ****) 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specify addresses of arrays holding data referring to the observed points. 
<p>
These arrays only need to be specified once, but this method may be called several times if it is desired to re-compute using different data arrays, or if the number of points or images changes. Note that it is only the addresses of the arrays that are stored - the data is not read in/out of the arrays until a compute method is called.<p>
Note that the constructor sets nPoints to NULL, indicating that there are no lines in any image or object, so if you don't want to use lines at all, you need not call this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>worldPoints</em>&nbsp;</td><td>world_points[image][obj][point][X|Y|Z]: The world coordinates of each point on each object, in the reference frame of the object, in the given image. Note that although the world points on each object are by definition fixed over time in its reference frame, not all points will generally be visible in each image, and this array holds only those that are visible - hence the need for the [image] index. </td></tr>
    <tr><td valign=top><em>imagePoints</em>&nbsp;</td><td>imagePoints[cam][image][obj][point][X|Y]: The image coordinates of each point on each object, in the given image for each camera. Set to (-1,-1) if the point was not seen for a given image from a given camera. Points that are not seen from any camera can be omitted simply by not including an entry for them in both the arrays. </td></tr>
    <tr><td valign=top><em>nPoints[image][obj]</em>&nbsp;</td><td>Number of observed points in each image for each object. Values in this array must not exceed the value of maxPoints specified in the constructor. </td></tr>
    <tr><td valign=top><em>nImages</em>&nbsp;</td><td>Number of separate time instants (images) at which observations were made. </td></tr>
    <tr><td valign=top><em>useImObj</em>&nbsp;</td><td>useImObj[image][obj]: specifies whether to use observations from each image of each object; if omitted then all images and objects will be used. </td></tr>
    <tr><td valign=top><em>usePoint</em>&nbsp;</td><td>usePoint[cam][image][obj][point]: specifies whether to use this observation; if omitted then all observed points will be used. Useful to "turn off" a particular individual observation, e.g. if it was considered an outlier. </td></tr>
    <tr><td valign=top><em>weightPoint</em>&nbsp;</td><td>weightPoint[cam][image][obj][line] specifies the weighting to apply to this observation of this point. Omitting this array sets a default weight of 1 to all points. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a11" doxytag="bbcvp::PoseEstimator::setTerminationConditions"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::setTerminationConditions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>rmsLimit</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>limit</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>maxRmsErrorIncrease</em> = 0.0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specify the conditions under which the iteraterative solution process terminates. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rmsLimit</em>&nbsp;</td><td>Stop iterating when rms error changes by less than this </td></tr>
    <tr><td valign=top><em>MaxIter</em>&nbsp;</td><td>The maximum number of iterations to perform </td></tr>
    <tr><td valign=top><em>limit</em>&nbsp;</td><td>The smallest length of the update vector allowed before iterations are stopped. </td></tr>
    <tr><td valign=top><em>MaxRmsErrorIncrease</em>&nbsp;</td><td>The max increase in RMS error allowed before solution vector is scaled down </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a12" doxytag="bbcvp::PoseEstimator::setVerbosity"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::setVerbosity </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>verbosity</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the verbosity level. 
<p>
A level of 0 means that nothing at all is printed. Higher values print increasingly more information. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>verbosity</em>&nbsp;</td><td>The verbosity level to set, 0..9 </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="PoseEstimator_8h-source.html#l00396">396</a> of file <a class="el" href="PoseEstimator_8h-source.html">PoseEstimator.h</a>.
<p>
Referenced by <a class="el" href="PoseEstPanTiltHead_8h-source.html#l00107">bbcvp::PoseEstPanTiltHead::setVerbosity()</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="bbcvp::PoseEstimator::setVerticalFOV"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::setVerticalFOV </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>fovyRad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the focal length of the given camera, for the given field-of-view in radians. 
<p>
Requires that internal parameters NY (number of vertical pixels) and YP (vertical pixel spacing) are already set for the given camera. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>fovyRad</em>&nbsp;</td><td>vertical field-of-view, in radians. </td></tr>
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>the number of the camera whose focal length to set </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a8" doxytag="bbcvp::PoseEstimator::setVerticalFOVDeg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bbcvp::PoseEstimator::setVerticalFOVDeg </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>fovy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cam</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the focal length of the given camera, for the given field-of-view in degrees. 
<p>
Requires that internal parameters NY (number of vertical pixels) and YP (vertical pixel spacing) are already set for the given camera <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>fovyRad</em>&nbsp;</td><td>vertical field-of-view, in radians. </td></tr>
    <tr><td valign=top><em>cam</em>&nbsp;</td><td>the number of the camera whose focal length to set </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PoseEstimator_8h-source.html">PoseEstimator.h</a></ul>
</td>
</tr>
  </tbody>
</table>
</body>
</html>
